// Copyright 2025 Erst Users
// SPDX-License-Identifier: Apache-2.0

package cmd

import (
	"context"
	"fmt"
	"os"

	"github.com/dotandev/hintents/internal/errors"
	"github.com/dotandev/hintents/internal/offline"
	"github.com/dotandev/hintents/internal/rpc"
	"github.com/spf13/cobra"
)

// Flag variables scoped to the offline command tree.
var (
	offlineNetworkFlag string
	offlineOutputFlag  string
	offlineKeyFlag     string
	offlineRPCURLFlag  string
	offlineDescFlag    string
	offlineSourceFlag  string
)

// offlineCmd is the parent command for the air-gapped signing workflow.
var offlineCmd = &cobra.Command{
	Use:   "offline",
	Short: "Air-gapped transaction signing pipeline",
	Long: `Manage the offline (air-gapped) transaction signing workflow.

The pipeline has four stages:
  1. generate  – Build an unsigned envelope and save it to a portable JSON file.
  2. sign      – Sign the envelope on an air-gapped machine with a secret key.
  3. verify    – Verify all signatures before submission.
  4. submit    – Submit the signed envelope to the Stellar network.

Example workflow:
  # On the online machine
  erst offline generate --network testnet --source GABC... -o tx.erst.json ./tx.xdr

  # Copy tx.erst.json to USB → bring to air-gapped machine
  erst offline sign --key <hex-seed> tx.erst.json

  # Copy signed tx.erst.json back via USB
  erst offline verify tx.erst.json
  erst offline submit tx.erst.json`,
}

// ── generate ────────────────────────────────────────────────────────────────

var offlineGenerateCmd = &cobra.Command{
	Use:   "generate <tx-envelope.xdr>",
	Short: "Generate a portable unsigned envelope file",
	Long: `Read a base64-encoded TransactionEnvelope XDR from a file and package it
into a portable JSON envelope that can be transferred to an air-gapped
machine for signing.`,
	Example: `  erst offline generate --network testnet -o tx.erst.json ./tx.xdr
  erst offline generate --network mainnet --source GABC... -o unsigned.json ./tx.xdr`,
	Args: cobra.ExactArgs(1),
	RunE: runOfflineGenerate,
}

func runOfflineGenerate(_ *cobra.Command, args []string) error {
	xdrPath := args[0]

	raw, err := os.ReadFile(xdrPath)
	if err != nil {
		return errors.WrapValidationError(fmt.Sprintf("failed to read XDR file: %v", err))
	}

	envelopeXDR := string(bytesTrimSpaceOffline(raw))
	if envelopeXDR == "" {
		return errors.WrapValidationError("XDR file is empty")
	}

	net := rpc.Network(offlineNetworkFlag)
	passphrase, err := passphraseForNetwork(net)
	if err != nil {
		return err
	}

	output := offlineOutputFlag
	if output == "" {
		output = "unsigned.erst.json"
	}

	meta := offline.EnvelopeMetadata{
		Description: offlineDescFlag,
		SourceAddr:  offlineSourceFlag,
		ErstVersion: Version,
	}

	ef := offline.NewEnvelopeFile(offlineNetworkFlag, passphrase, envelopeXDR, meta)

	if err := ef.SaveToFile(output); err != nil {
		return err
	}

	fmt.Printf("Unsigned envelope saved to %s\n", output)
	fmt.Printf("  Network:  %s\n", offlineNetworkFlag)
	fmt.Printf("  Checksum: %s\n", ef.Checksum)
	fmt.Println("\nTransfer this file to the air-gapped machine and run:")
	fmt.Printf("  erst offline sign --key <hex-seed> %s\n", output)

	return nil
}

// ── sign ────────────────────────────────────────────────────────────────────

var offlineSignCmd = &cobra.Command{
	Use:   "sign <envelope.erst.json>",
	Short: "Sign an envelope file with a secret key",
	Long: `Load a portable envelope file generated by 'erst offline generate',
sign the envelope XDR with the provided ed25519 private key, and
write the signature back into the file.

The key can be a 32-byte seed or a 64-byte full private key, hex-encoded.
It can be passed via --key flag or the ERST_SIGN_KEY environment variable.`,
	Example: `  erst offline sign --key <hex-seed> tx.erst.json
  ERST_SIGN_KEY=<hex-seed> erst offline sign tx.erst.json`,
	Args: cobra.ExactArgs(1),
	RunE: runOfflineSign,
}

func runOfflineSign(_ *cobra.Command, args []string) error {
	path := args[0]

	key := offlineKeyFlag
	if key == "" {
		key = os.Getenv("ERST_SIGN_KEY")
	}
	if key == "" {
		return errors.WrapValidationError("private key is required (use --key or ERST_SIGN_KEY env var)")
	}

	ef, err := offline.LoadEnvelopeFile(path)
	if err != nil {
		return err
	}

	if err := offline.SignEnvelope(ef, key); err != nil {
		return err
	}

	if err := ef.SaveToFile(path); err != nil {
		return err
	}

	fmt.Printf("Envelope signed successfully (%d total signature(s))\n", len(ef.Signatures))
	fmt.Printf("  File: %s\n", path)
	fmt.Println("\nNext steps:")
	fmt.Printf("  erst offline verify %s\n", path)
	fmt.Printf("  erst offline submit %s\n", path)

	return nil
}

// ── verify ──────────────────────────────────────────────────────────────────

var offlineVerifyCmd = &cobra.Command{
	Use:     "verify <envelope.erst.json>",
	Short:   "Verify all signatures on an envelope file",
	Long:    `Load a signed envelope file and verify every attached signature.`,
	Example: `  erst offline verify tx.erst.json`,
	Args:    cobra.ExactArgs(1),
	RunE:    runOfflineVerify,
}

func runOfflineVerify(_ *cobra.Command, args []string) error {
	ef, err := offline.LoadEnvelopeFile(args[0])
	if err != nil {
		return err
	}

	if err := offline.VerifySignatures(ef); err != nil {
		return err
	}

	fmt.Printf("All %d signature(s) verified successfully\n", len(ef.Signatures))
	for i, sig := range ef.Signatures {
		fmt.Printf("  [%d] key=%s signed_at=%s\n", i, sig.PublicKey[:16]+"...", sig.SignedAt)
	}

	return nil
}

// ── submit ──────────────────────────────────────────────────────────────────

var offlineSubmitCmd = &cobra.Command{
	Use:   "submit <envelope.erst.json>",
	Short: "Submit a signed envelope to the Stellar network",
	Long: `Load a signed and verified envelope file and submit it to the Stellar
network via the Soroban RPC sendTransaction endpoint.`,
	Example: `  erst offline submit tx.erst.json
  erst offline submit --rpc-url https://custom-rpc.example.com tx.erst.json`,
	Args: cobra.ExactArgs(1),
	RunE: runOfflineSubmit,
}

func runOfflineSubmit(cmd *cobra.Command, args []string) error {
	ef, err := offline.LoadEnvelopeFile(args[0])
	if err != nil {
		return err
	}

	if !ef.IsSigned() {
		return errors.WrapValidationError("envelope has no signatures; sign it first with 'erst offline sign'")
	}

	// Verify before submitting.
	if err := offline.VerifySignatures(ef); err != nil {
		return fmt.Errorf("pre-submit verification failed: %w", err)
	}

	rpcURL := offlineRPCURLFlag
	if rpcURL == "" {
		rpcURL, err = offline.SorobanURLForNetwork(ef.Network)
		if err != nil {
			return err
		}
	}

	ctx := cmd.Context()
	if ctx == nil {
		ctx = context.Background()
	}

	fmt.Printf("Submitting to %s (%s)...\n", ef.Network, rpcURL)

	resp, err := offline.SubmitSignedEnvelope(ctx, rpcURL, ef.EnvelopeXDR)
	if err != nil {
		return err
	}

	fmt.Printf("Transaction submitted successfully\n")
	fmt.Printf("  Status: %s\n", resp.Result.Status)
	if resp.Result.Hash != "" {
		fmt.Printf("  Hash:   %s\n", resp.Result.Hash)
	}

	return nil
}

// ── helpers ─────────────────────────────────────────────────────────────────

func passphraseForNetwork(net rpc.Network) (string, error) {
	switch net {
	case rpc.Testnet:
		return "Test SDF Network ; September 2015", nil
	case rpc.Mainnet:
		return "Public Global Stellar Network ; September 2015", nil
	case rpc.Futurenet:
		return "Test SDF Future Network ; October 2022", nil
	default:
		return "", errors.WrapInvalidNetwork(string(net))
	}
}

// bytesTrimSpaceOffline trims surrounding whitespace from a byte slice.
func bytesTrimSpaceOffline(b []byte) []byte {
	start := 0
	for start < len(b) && isSpace(b[start]) {
		start++
	}
	end := len(b)
	for end > start && isSpace(b[end-1]) {
		end--
	}
	return b[start:end]
}

func isSpace(c byte) bool {
	return c == ' ' || c == '\n' || c == '\r' || c == '\t'
}

// ── init ────────────────────────────────────────────────────────────────────

func init() {
	// generate flags
	offlineGenerateCmd.Flags().StringVarP(&offlineNetworkFlag, "network", "n", string(rpc.Mainnet), "Target Stellar network (testnet, mainnet, futurenet)")
	offlineGenerateCmd.Flags().StringVarP(&offlineOutputFlag, "output", "o", "", "Output file path (default: unsigned.erst.json)")
	offlineGenerateCmd.Flags().StringVar(&offlineDescFlag, "desc", "", "Human-readable description to embed in the file")
	offlineGenerateCmd.Flags().StringVar(&offlineSourceFlag, "source", "", "Source account address to embed in metadata")

	// sign flags
	offlineSignCmd.Flags().StringVar(&offlineKeyFlag, "key", "", "Hex-encoded ed25519 private key (32-byte seed or 64-byte full key)")

	// submit flags
	offlineSubmitCmd.Flags().StringVar(&offlineRPCURLFlag, "rpc-url", "", "Custom Soroban RPC URL (overrides network default)")

	// wire tree
	offlineCmd.AddCommand(offlineGenerateCmd)
	offlineCmd.AddCommand(offlineSignCmd)
	offlineCmd.AddCommand(offlineVerifyCmd)
	offlineCmd.AddCommand(offlineSubmitCmd)

	rootCmd.AddCommand(offlineCmd)
}
