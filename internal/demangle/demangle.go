// Copyright 2025 Erst Users
// SPDX-License-Identifier: Apache-2.0

// Package demangle takes Rust symbols generated by rustc and turns them into
// readable names. It also replaces raw WASM function indices (like func[42])
// inside trace output with their corresponding Rust function names.
//
// Rust uses a well-defined name mangling scheme. A mangled symbol looks like:
//
//	_ZN11my_contract6invoke17h1a2b3c4d5e6f7890E   (legacy / Itanium)
//	_RNvCs1234abcd_11my_contract6invoke             (v0 / RFC 2603)
//
// After demangling, both resolve to: my_contract::invoke
//
// WASM function references look like: func[42]
// If a symbol table is available, we use it to replace those indices with
// their demangled names.
package demangle

import (
	"fmt"
	"regexp"
	"strings"
)

// Matches WASM function references like "func[42]".
var reWASMFuncID = regexp.MustCompile(`func\[(\d+)\]`)

// SymbolTable maps WASM function indices to their mangled Rust names.
// These are typically extracted from the module's name section or debug info.
type SymbolTable map[uint32]string

// SymbolEntry represents a single function entry from the WASM name section.
type SymbolEntry struct {
	Index       uint32
	MangledName string
}

// SymbolEntry represents a single function entry from the WASM name section.
func BuildSymbolTable(entries []SymbolEntry) SymbolTable {
	table := make(SymbolTable, len(entries))
	for _, e := range entries {
		table[e.Index] = e.MangledName
	}
	return table
}

// DemangleSymbol converts a mangled Rust symbol into a readable path
// like "my_contract::invoke".
//
// Supports both legacy (_ZN...E) and v0 (_R...) formats.
// If the symbol is already readable or uses an unknown scheme,
// it’s returned unchanged.
func DemangleSymbol(mangled string) string {
	if mangled == "" {
		return mangled
	}

	if strings.HasPrefix(mangled, "_R") {
		return demangleV0(mangled)
	}

	if strings.HasPrefix(mangled, "_ZN") {
		return demangleLegacy(mangled)
	}

	// already readable or unknown scheme return as-is.
	return mangled
}

// DemangleTrace scans a trace string and replaces every "func[N]"
// reference with the corresponding demangled Rust name from the symbol table.
//
// If an index isn’t found in the table, the original token is left intact.
//
// Example:
//
//	input:  "call func[42] -> func[7]"
//	output: "call my_contract::invoke -> soroban_sdk::log"
func DemangleTrace(trace string, table SymbolTable) string {
	if len(table) == 0 {
		return trace
	}

	return reWASMFuncID.ReplaceAllStringFunc(trace, func(match string) string {
		var idx uint32
		if _, err := fmt.Sscanf(match, "func[%d]", &idx); err != nil {
			return match
		}

		mangled, ok := table[idx]
		if !ok {
			return match
		}

		return DemangleSymbol(mangled)
	})
}

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

// demangleLegacy decodes an Itanium-mangled Rust symbol (_ZN...E).
//
// Encoding: _ZN <len><ident>... <hash-suffix> E
// The hash suffix (17h<hex>) is dropped. Identifiers are joined with "::".
func demangleLegacy(sym string) string {
	inner := strings.TrimPrefix(sym, "_ZN")
	inner = strings.TrimSuffix(inner, "E")

	parts := parseLengthPrefixed(inner)
	if len(parts) == 0 {
		return sym
	}

	// Drop rustc hash suffix last segment of the form h<hex>
	if len(parts) > 1 && isHashSuffix(parts[len(parts)-1]) {
		parts = parts[:len(parts)-1]
	}

	return strings.Join(parts, "::")
}

// demangleV0 handles v0 / RFC-2603 Rust symbols (_R...).
// This implementation focuses on the common subset that appears
// in Soroban contract traces.
func demangleV0(sym string) string {
	inner := strings.TrimPrefix(sym, "_R")
	parts := parseV0Path(inner)
	if len(parts) == 0 {
		return sym
	}
	return strings.Join(parts, "::")
}

// demangleV0 handles v0 / RFC-2603 Rust symbols (_R...).
// This implementation focuses on the common subset that appears
// in Soroban contract traces.
func parseLengthPrefixed(s string) []string {
	var parts []string
	for len(s) > 0 {
		n := 0
		i := 0
		for i < len(s) && s[i] >= '0' && s[i] <= '9' {
			n = n*10 + int(s[i]-'0')
			i++
		}
		if i == 0 || i+n > len(s) {
			break
		}
		parts = append(parts, s[i:i+n])
		s = s[i+n:]
	}
	return parts
}

// parseV0Path does a best-effort extraction of path segments from a v0 symbol.
func parseV0Path(s string) []string {
	// Strip non-alphanumeric or underscore chars used as v0 structural markers.
	cleaned := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_' {
			return r
		}
		return -1
	}, s)
	return parseLengthPrefixed(cleaned)
}

// isHashSuffix reports whether seg is a rustc hash suffix like "h1a2b3c4d5e6f7890".
func isHashSuffix(seg string) bool {
	if len(seg) < 2 || seg[0] != 'h' {
		return false
	}
	for _, c := range seg[1:] {
		if !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {
			return false
		}
	}
	return true
}
