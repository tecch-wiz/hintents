// Copyright 2025 Erst Users
// SPDX-License-Identifier: Apache-2.0

package bindings

import (
	"fmt"
	"strings"

	"github.com/dotandev/hintents/internal/abi"
	"github.com/stellar/go-stellar-sdk/xdr"
)

// GeneratorConfig holds configuration for TypeScript bindings generation
type GeneratorConfig struct {
	WasmBytes   []byte
	OutputDir   string
	PackageName string
	ContractID  string
	Network     string
}

// GeneratedFile represents a generated TypeScript file
type GeneratedFile struct {
	Path    string
	Content string
}

// Generator generates TypeScript bindings from Soroban contract specs
type Generator struct {
	config GeneratorConfig
	spec   *abi.ContractSpec
}

// NewGenerator creates a new bindings generator
func NewGenerator(config GeneratorConfig) *Generator {
	return &Generator{
		config: config,
	}
}

// Generate extracts the contract spec and generates TypeScript bindings
func (g *Generator) Generate() ([]GeneratedFile, error) {
	// Extract contract spec from WASM
	specBytes, err := abi.ExtractCustomSection(g.config.WasmBytes, "contractspecv0")
	if err != nil {
		return nil, fmt.Errorf("failed to extract contract spec: %w", err)
	}
	if specBytes == nil {
		return nil, fmt.Errorf("contract spec not found in WASM file")
	}

	// Decode contract spec
	g.spec, err = abi.DecodeContractSpec(specBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to decode contract spec: %w", err)
	}

	// Generate files
	files := []GeneratedFile{
		{
			Path:    "types.ts",
			Content: g.generateTypes(),
		},
		{
			Path:    "client.ts",
			Content: g.generateClient(),
		},
		{
			Path:    "erst-integration.ts",
			Content: g.generateErstIntegration(),
		},
		{
			Path:    "index.ts",
			Content: g.generateIndex(),
		},
		{
			Path:    "package.json",
			Content: g.generatePackageJSON(),
		},
		{
			Path:    "README.md",
			Content: g.generateReadme(),
		},
	}

	return files, nil
}

// generateTypes generates TypeScript type definitions
func (g *Generator) generateTypes() string {
	var b strings.Builder

	b.WriteString("// Auto-generated TypeScript types for Soroban contract\n")
	b.WriteString("// DO NOT EDIT - Generated by erst generate-bindings\n\n")

	// Generate base types
	b.WriteString("export type Address = string;\n")
	b.WriteString("export type Bytes = Uint8Array;\n")
	b.WriteString("export type Symbol = string;\n\n")

	// Generate struct types
	if len(g.spec.Structs) > 0 {
		b.WriteString("// Struct Types\n")
		for _, s := range g.spec.Structs {
			g.generateStructType(&b, s)
		}
		b.WriteString("\n")
	}

	// Generate enum types
	if len(g.spec.Enums) > 0 {
		b.WriteString("// Enum Types\n")
		for _, e := range g.spec.Enums {
			g.generateEnumType(&b, e)
		}
		b.WriteString("\n")
	}

	// Generate union types
	if len(g.spec.Unions) > 0 {
		b.WriteString("// Union Types\n")
		for _, u := range g.spec.Unions {
			g.generateUnionType(&b, u)
		}
		b.WriteString("\n")
	}

	// Generate error enum types
	if len(g.spec.ErrorEnums) > 0 {
		b.WriteString("// Error Types\n")
		for _, e := range g.spec.ErrorEnums {
			g.generateErrorEnumType(&b, e)
		}
		b.WriteString("\n")
	}

	// Generate event types
	if len(g.spec.Events) > 0 {
		b.WriteString("// Event Types\n")
		for _, ev := range g.spec.Events {
			g.generateEventType(&b, ev)
		}
	}

	return b.String()
}

func (g *Generator) generateStructType(b *strings.Builder, s xdr.ScSpecUdtStructV0) {
	structName := string(s.Name)

	if s.Doc != "" {
		b.WriteString(fmt.Sprintf("/** %s */\n", s.Doc))
	}

	b.WriteString(fmt.Sprintf("export interface %s {\n", structName))
	for _, field := range s.Fields {
		tsType := g.mapTypeDefToTS(field.Type)
		b.WriteString(fmt.Sprintf("  %s: %s;\n", field.Name, tsType))
	}
	b.WriteString("}\n\n")
}

func (g *Generator) generateEnumType(b *strings.Builder, e xdr.ScSpecUdtEnumV0) {
	enumName := string(e.Name)

	if e.Doc != "" {
		b.WriteString(fmt.Sprintf("/** %s */\n", e.Doc))
	}

	b.WriteString(fmt.Sprintf("export enum %s {\n", enumName))
	for _, c := range e.Cases {
		b.WriteString(fmt.Sprintf("  %s = %d,\n", c.Name, c.Value))
	}
	b.WriteString("}\n\n")
}

func (g *Generator) generateUnionType(b *strings.Builder, u xdr.ScSpecUdtUnionV0) {
	unionName := string(u.Name)

	if u.Doc != "" {
		b.WriteString(fmt.Sprintf("/** %s */\n", u.Doc))
	}

	// Generate discriminated union
	b.WriteString(fmt.Sprintf("export type %s = \n", unionName))

	for i, c := range u.Cases {
		switch c.Kind {
		case xdr.ScSpecUdtUnionCaseV0KindScSpecUdtUnionCaseVoidV0:
			b.WriteString(fmt.Sprintf("  | { tag: '%s' }", c.VoidCase.Name))
		case xdr.ScSpecUdtUnionCaseV0KindScSpecUdtUnionCaseTupleV0:
			types := make([]string, len(c.TupleCase.Type))
			for j, t := range c.TupleCase.Type {
				types[j] = g.mapTypeDefToTS(t)
			}
			b.WriteString(fmt.Sprintf("  | { tag: '%s'; values: [%s] }",
				c.TupleCase.Name, strings.Join(types, ", ")))
		}

		if i < len(u.Cases)-1 {
			b.WriteString("\n")
		}
	}
	b.WriteString(";\n\n")
}

func (g *Generator) generateErrorEnumType(b *strings.Builder, e xdr.ScSpecUdtErrorEnumV0) {
	enumName := string(e.Name)

	if e.Doc != "" {
		b.WriteString(fmt.Sprintf("/** %s */\n", e.Doc))
	}

	b.WriteString(fmt.Sprintf("export enum %s {\n", enumName))
	for _, c := range e.Cases {
		b.WriteString(fmt.Sprintf("  %s = %d,\n", c.Name, c.Value))
	}
	b.WriteString("}\n\n")

	// Generate error class
	b.WriteString(fmt.Sprintf("export class %sError extends Error {\n", enumName))
	b.WriteString(fmt.Sprintf("  constructor(public code: %s, message?: string) {\n", enumName))
	b.WriteString("    super(message || `Contract error: ${code}`);\n")
	b.WriteString("    this.name = '" + enumName + "Error';\n")
	b.WriteString("  }\n")
	b.WriteString("}\n\n")
}

func (g *Generator) generateEventType(b *strings.Builder, ev xdr.ScSpecEventV0) {
	eventName := string(ev.Name)

	if ev.Doc != "" {
		b.WriteString(fmt.Sprintf("/** %s */\n", ev.Doc))
	}

	b.WriteString(fmt.Sprintf("export interface %sEvent {\n", eventName))
	for _, param := range ev.Params {
		tsType := g.mapTypeDefToTS(param.Type)
		location := "data"
		if param.Location == xdr.ScSpecEventParamLocationV0ScSpecEventParamLocationTopicList {
			location = "topic"
		}
		b.WriteString(fmt.Sprintf("  %s: %s; // %s\n", param.Name, tsType, location))
	}
	b.WriteString("}\n\n")
}

// mapTypeDefToTS converts Soroban type definitions to TypeScript types
func (g *Generator) mapTypeDefToTS(td xdr.ScSpecTypeDef) string {
	switch td.Type {
	case xdr.ScSpecTypeScSpecTypeVal:
		return "any"
	case xdr.ScSpecTypeScSpecTypeBool:
		return "boolean"
	case xdr.ScSpecTypeScSpecTypeVoid:
		return "void"
	case xdr.ScSpecTypeScSpecTypeError:
		return "Error"
	case xdr.ScSpecTypeScSpecTypeU32, xdr.ScSpecTypeScSpecTypeI32:
		return "number"
	case xdr.ScSpecTypeScSpecTypeU64, xdr.ScSpecTypeScSpecTypeI64:
		return "bigint"
	case xdr.ScSpecTypeScSpecTypeTimepoint:
		return "Date"
	case xdr.ScSpecTypeScSpecTypeDuration:
		return "number"
	case xdr.ScSpecTypeScSpecTypeU128, xdr.ScSpecTypeScSpecTypeI128:
		return "bigint"
	case xdr.ScSpecTypeScSpecTypeU256, xdr.ScSpecTypeScSpecTypeI256:
		return "bigint"
	case xdr.ScSpecTypeScSpecTypeBytes:
		return "Bytes"
	case xdr.ScSpecTypeScSpecTypeString:
		return "string"
	case xdr.ScSpecTypeScSpecTypeSymbol:
		return "Symbol"
	case xdr.ScSpecTypeScSpecTypeAddress:
		return "Address"
	case xdr.ScSpecTypeScSpecTypeMuxedAddress:
		return "Address"
	case xdr.ScSpecTypeScSpecTypeOption:
		if td.Option != nil {
			innerType := g.mapTypeDefToTS(td.Option.ValueType)
			return fmt.Sprintf("%s | null", innerType)
		}
		return "any | null"
	case xdr.ScSpecTypeScSpecTypeResult:
		if td.Result != nil {
			okType := g.mapTypeDefToTS(td.Result.OkType)
			errType := g.mapTypeDefToTS(td.Result.ErrorType)
			return fmt.Sprintf("Result<%s, %s>", okType, errType)
		}
		return "Result<any, any>"
	case xdr.ScSpecTypeScSpecTypeVec:
		if td.Vec != nil {
			elemType := g.mapTypeDefToTS(td.Vec.ElementType)
			return fmt.Sprintf("%s[]", elemType)
		}
		return "any[]"
	case xdr.ScSpecTypeScSpecTypeMap:
		if td.Map != nil {
			keyType := g.mapTypeDefToTS(td.Map.KeyType)
			valType := g.mapTypeDefToTS(td.Map.ValueType)
			return fmt.Sprintf("Map<%s, %s>", keyType, valType)
		}
		return "Map<any, any>"
	case xdr.ScSpecTypeScSpecTypeTuple:
		if td.Tuple != nil {
			types := make([]string, len(td.Tuple.ValueTypes))
			for i, t := range td.Tuple.ValueTypes {
				types[i] = g.mapTypeDefToTS(t)
			}
			return fmt.Sprintf("[%s]", strings.Join(types, ", "))
		}
		return "[]"
	case xdr.ScSpecTypeScSpecTypeBytesN:
		if td.BytesN != nil {
			return fmt.Sprintf("Uint8Array /* length: %d */", td.BytesN.N)
		}
		return "Uint8Array"
	case xdr.ScSpecTypeScSpecTypeUdt:
		if td.Udt != nil {
			return td.Udt.Name
		}
		return "any"
	default:
		return "any"
	}
}

// generateClient generates the main TypeScript client class
func (g *Generator) generateClient() string {
	var b strings.Builder

	b.WriteString("// Auto-generated TypeScript client for Soroban contract\n")
	b.WriteString("// DO NOT EDIT - Generated by erst generate-bindings\n\n")

	b.WriteString("import * as StellarSdk from '@stellar/stellar-sdk';\n")
	b.WriteString("import { ErstSimulator } from './erst-integration';\n")
	b.WriteString("import * as Types from './types';\n\n")

	// Generate client configuration interface
	b.WriteString("export interface ClientConfig {\n")
	b.WriteString("  contractId: string;\n")
	b.WriteString("  network: 'testnet' | 'mainnet' | 'futurenet';\n")
	b.WriteString("  rpcUrl?: string;\n")
	b.WriteString("  enableSimulation?: boolean;\n")
	b.WriteString("}\n\n")

	// Generate method options interface
	b.WriteString("export interface CallOptions {\n")
	b.WriteString("  simulate?: boolean;\n")
	b.WriteString("  fee?: string;\n")
	b.WriteString("  memo?: StellarSdk.Memo;\n")
	b.WriteString("  timeoutInSeconds?: number;\n")
	b.WriteString("}\n\n")

	// Generate result type
	b.WriteString("export interface CallResult<T> {\n")
	b.WriteString("  result: T;\n")
	b.WriteString("  transactionHash?: string;\n")
	b.WriteString("  simulation?: any;\n")
	b.WriteString("}\n\n")

	// Generate main client class
	className := toPascalCase(g.config.PackageName) + "Client"
	b.WriteString(fmt.Sprintf("export class %s {\n", className))
	b.WriteString("  private config: ClientConfig;\n")
	b.WriteString("  private server: StellarSdk.SorobanRpc.Server;\n")
	b.WriteString("  private simulator?: ErstSimulator;\n\n")

	// Constructor
	b.WriteString("  constructor(config: ClientConfig) {\n")
	b.WriteString("    this.config = config;\n")
	b.WriteString("    \n")
	b.WriteString("    // Initialize Soroban RPC server\n")
	b.WriteString("    const networkUrl = config.rpcUrl || this.getDefaultRpcUrl(config.network);\n")
	b.WriteString("    this.server = new StellarSdk.SorobanRpc.Server(networkUrl);\n")
	b.WriteString("    \n")
	b.WriteString("    // Initialize erst simulator if enabled\n")
	b.WriteString("    if (config.enableSimulation) {\n")
	b.WriteString("      this.simulator = new ErstSimulator({\n")
	b.WriteString("        network: config.network,\n")
	b.WriteString("        rpcUrl: networkUrl,\n")
	b.WriteString("      });\n")
	b.WriteString("    }\n")
	b.WriteString("  }\n\n")

	// Helper method for default RPC URL
	b.WriteString("  private getDefaultRpcUrl(network: string): string {\n")
	b.WriteString("    switch (network) {\n")
	b.WriteString("      case 'testnet':\n")
	b.WriteString("        return 'https://soroban-testnet.stellar.org';\n")
	b.WriteString("      case 'mainnet':\n")
	b.WriteString("        return 'https://soroban-mainnet.stellar.org';\n")
	b.WriteString("      case 'futurenet':\n")
	b.WriteString("        return 'https://rpc-futurenet.stellar.org';\n")
	b.WriteString("      default:\n")
	b.WriteString("        throw new Error(`Unknown network: ${network}`);\n")
	b.WriteString("    }\n")
	b.WriteString("  }\n\n")

	// Generate methods for each function
	if len(g.spec.Functions) > 0 {
		b.WriteString("  // Contract Methods\n\n")
		for _, fn := range g.spec.Functions {
			g.generateClientMethod(&b, fn)
		}
	}

	// Add helper methods
	g.generateHelperMethods(&b)

	b.WriteString("}\n")

	return b.String()
}

func (g *Generator) generateClientMethod(b *strings.Builder, fn xdr.ScSpecFunctionV0) {
	methodName := string(fn.Name)

	// Generate JSDoc comment
	if fn.Doc != "" {
		b.WriteString(fmt.Sprintf("  /** %s */\n", fn.Doc))
	}

	// Generate method signature
	params := make([]string, 0, len(fn.Inputs)+2)
	params = append(params, "source: StellarSdk.Keypair")

	for _, inp := range fn.Inputs {
		tsType := g.mapTypeDefToTS(inp.Type)
		params = append(params, fmt.Sprintf("%s: %s", inp.Name, tsType))
	}

	params = append(params, "options?: CallOptions")

	returnType := "void"
	if len(fn.Outputs) > 0 {
		returnType = g.mapTypeDefToTS(fn.Outputs[0])
	}

	b.WriteString(fmt.Sprintf("  async %s(%s): Promise<CallResult<%s>> {\n",
		methodName, strings.Join(params, ", "), returnType))

	// Method body
	b.WriteString("    const opts = options || {};\n\n")

	// Build transaction
	b.WriteString("    // Build contract call transaction\n")
	b.WriteString("    const contract = new StellarSdk.Contract(this.config.contractId);\n")
	b.WriteString(fmt.Sprintf("    const operation = contract.call('%s'", methodName))

	if len(fn.Inputs) > 0 {
		for _, inp := range fn.Inputs {
			b.WriteString(fmt.Sprintf(", %s", inp.Name))
		}
	}

	b.WriteString(");\n\n")

	b.WriteString("    const account = await this.server.getAccount(source.publicKey());\n")
	b.WriteString("    const txBuilder = new StellarSdk.TransactionBuilder(account, {\n")
	b.WriteString("      fee: opts.fee || StellarSdk.BASE_FEE,\n")
	b.WriteString("      networkPassphrase: this.getNetworkPassphrase(),\n")
	b.WriteString("    });\n\n")

	b.WriteString("    if (opts.memo) {\n")
	b.WriteString("      txBuilder.addMemo(opts.memo);\n")
	b.WriteString("    }\n\n")

	b.WriteString("    const tx = txBuilder\n")
	b.WriteString("      .addOperation(operation)\n")
	b.WriteString("      .setTimeout(opts.timeoutInSeconds || 30)\n")
	b.WriteString("      .build();\n\n")

	// Simulation with erst
	b.WriteString("    // Simulate with erst if enabled\n")
	b.WriteString("    if (opts.simulate && this.simulator) {\n")
	b.WriteString("      const simResult = await this.simulator.simulate(tx);\n")
	b.WriteString("      return {\n")
	b.WriteString("        result: simResult.result as " + returnType + ",\n")
	b.WriteString("        simulation: simResult,\n")
	b.WriteString("      };\n")
	b.WriteString("    }\n\n")

	// Execute transaction
	b.WriteString("    // Sign and submit transaction\n")
	b.WriteString("    tx.sign(source);\n")
	b.WriteString("    const response = await this.server.sendTransaction(tx);\n\n")

	b.WriteString("    // Wait for confirmation\n")
	b.WriteString("    if (response.status === 'PENDING') {\n")
	b.WriteString("      const txResult = await this.server.getTransaction(response.hash);\n")
	b.WriteString("      // Parse result and return\n")
	b.WriteString("      return {\n")
	b.WriteString("        result: this.parseResult(txResult) as " + returnType + ",\n")
	b.WriteString("        transactionHash: response.hash,\n")
	b.WriteString("      };\n")
	b.WriteString("    }\n\n")

	b.WriteString("    throw new Error(`Transaction failed: ${response.status}`);\n")
	b.WriteString("  }\n\n")
}

func (g *Generator) generateHelperMethods(b *strings.Builder) {
	b.WriteString("  // Helper Methods\n\n")

	b.WriteString("  private getNetworkPassphrase(): string {\n")
	b.WriteString("    switch (this.config.network) {\n")
	b.WriteString("      case 'testnet':\n")
	b.WriteString("        return StellarSdk.Networks.TESTNET;\n")
	b.WriteString("      case 'mainnet':\n")
	b.WriteString("        return StellarSdk.Networks.PUBLIC;\n")
	b.WriteString("      case 'futurenet':\n")
	b.WriteString("        return StellarSdk.Networks.FUTURENET;\n")
	b.WriteString("      default:\n")
	b.WriteString("        throw new Error(`Unknown network: ${this.config.network}`);\n")
	b.WriteString("    }\n")
	b.WriteString("  }\n\n")

	b.WriteString("  private parseResult(txResult: any): any {\n")
	b.WriteString("    // Parse transaction result from Soroban RPC response\n")
	b.WriteString("    if (txResult.status === 'SUCCESS' && txResult.returnValue) {\n")
	b.WriteString("      return StellarSdk.scValToNative(txResult.returnValue);\n")
	b.WriteString("    }\n")
	b.WriteString("    throw new Error('Transaction failed or no return value');\n")
	b.WriteString("  }\n")
}

// generateErstIntegration generates the erst simulator integration
func (g *Generator) generateErstIntegration() string {
	var b strings.Builder

	b.WriteString("// Erst simulator integration for local testing and debugging\n")
	b.WriteString("// DO NOT EDIT - Generated by erst generate-bindings\n\n")

	b.WriteString("import { spawn } from 'child_process';\n")
	b.WriteString("import * as StellarSdk from '@stellar/stellar-sdk';\n\n")

	b.WriteString("export interface ErstConfig {\n")
	b.WriteString("  network: string;\n")
	b.WriteString("  rpcUrl: string;\n")
	b.WriteString("  erstPath?: string;\n")
	b.WriteString("}\n\n")

	b.WriteString("export interface SimulationResult {\n")
	b.WriteString("  status: 'success' | 'error';\n")
	b.WriteString("  result?: any;\n")
	b.WriteString("  error?: string;\n")
	b.WriteString("  events?: any[];\n")
	b.WriteString("  logs?: string[];\n")
	b.WriteString("  budgetUsage?: {\n")
	b.WriteString("    cpuInstructions: number;\n")
	b.WriteString("    memoryBytes: number;\n")
	b.WriteString("    cpuUsagePercent: number;\n")
	b.WriteString("    memoryUsagePercent: number;\n")
	b.WriteString("  };\n")
	b.WriteString("}\n\n")

	b.WriteString("export class ErstSimulator {\n")
	b.WriteString("  private config: ErstConfig;\n\n")

	b.WriteString("  constructor(config: ErstConfig) {\n")
	b.WriteString("    this.config = config;\n")
	b.WriteString("  }\n\n")

	b.WriteString("  async simulate(tx: StellarSdk.Transaction): Promise<SimulationResult> {\n")
	b.WriteString("    const erstPath = this.config.erstPath || 'erst';\n")
	b.WriteString("    \n")
	b.WriteString("    // Convert transaction to XDR\n")
	b.WriteString("    const envelopeXdr = tx.toEnvelope().toXDR('base64');\n")
	b.WriteString("    \n")
	b.WriteString("    return new Promise((resolve, reject) => {\n")
	b.WriteString("      const args = [\n")
	b.WriteString("        'simulate',\n")
	b.WriteString("        '--network', this.config.network,\n")
	b.WriteString("        '--rpc-url', this.config.rpcUrl,\n")
	b.WriteString("        '--json',\n")
	b.WriteString("      ];\n\n")

	b.WriteString("      const erst = spawn(erstPath, args);\n")
	b.WriteString("      let stdout = '';\n")
	b.WriteString("      let stderr = '';\n\n")

	b.WriteString("      erst.stdin.write(envelopeXdr);\n")
	b.WriteString("      erst.stdin.end();\n\n")

	b.WriteString("      erst.stdout.on('data', (data) => {\n")
	b.WriteString("        stdout += data.toString();\n")
	b.WriteString("      });\n\n")

	b.WriteString("      erst.stderr.on('data', (data) => {\n")
	b.WriteString("        stderr += data.toString();\n")
	b.WriteString("      });\n\n")

	b.WriteString("      erst.on('close', (code) => {\n")
	b.WriteString("        if (code !== 0) {\n")
	b.WriteString("          reject(new Error(`erst exited with code ${code}: ${stderr}`));\n")
	b.WriteString("          return;\n")
	b.WriteString("        }\n\n")

	b.WriteString("        try {\n")
	b.WriteString("          const result = JSON.parse(stdout);\n")
	b.WriteString("          resolve(result);\n")
	b.WriteString("        } catch (err) {\n")
	b.WriteString("          reject(new Error(`Failed to parse erst output: ${err}`));\n")
	b.WriteString("        }\n")
	b.WriteString("      });\n")
	b.WriteString("    });\n")
	b.WriteString("  }\n\n")

	b.WriteString("  async debugTransaction(txHash: string): Promise<SimulationResult> {\n")
	b.WriteString("    const erstPath = this.config.erstPath || 'erst';\n")
	b.WriteString("    \n")
	b.WriteString("    return new Promise((resolve, reject) => {\n")
	b.WriteString("      const args = [\n")
	b.WriteString("        'debug',\n")
	b.WriteString("        '--network', this.config.network,\n")
	b.WriteString("        '--rpc-url', this.config.rpcUrl,\n")
	b.WriteString("        '--json',\n")
	b.WriteString("        txHash,\n")
	b.WriteString("      ];\n\n")

	b.WriteString("      const erst = spawn(erstPath, args);\n")
	b.WriteString("      let stdout = '';\n")
	b.WriteString("      let stderr = '';\n\n")

	b.WriteString("      erst.stdout.on('data', (data) => {\n")
	b.WriteString("        stdout += data.toString();\n")
	b.WriteString("      });\n\n")

	b.WriteString("      erst.stderr.on('data', (data) => {\n")
	b.WriteString("        stderr += data.toString();\n")
	b.WriteString("      });\n\n")

	b.WriteString("      erst.on('close', (code) => {\n")
	b.WriteString("        if (code !== 0) {\n")
	b.WriteString("          reject(new Error(`erst exited with code ${code}: ${stderr}`));\n")
	b.WriteString("          return;\n")
	b.WriteString("        }\n\n")

	b.WriteString("        try {\n")
	b.WriteString("          const result = JSON.parse(stdout);\n")
	b.WriteString("          resolve(result);\n")
	b.WriteString("        } catch (err) {\n")
	b.WriteString("          reject(new Error(`Failed to parse erst output: ${err}`));\n")
	b.WriteString("        }\n")
	b.WriteString("      });\n")
	b.WriteString("    });\n")
	b.WriteString("  }\n")
	b.WriteString("}\n")

	return b.String()
}

// generateIndex generates the main index.ts export file
func (g *Generator) generateIndex() string {
	var b strings.Builder

	b.WriteString("// Auto-generated index file\n")
	b.WriteString("// DO NOT EDIT - Generated by erst generate-bindings\n\n")

	b.WriteString("export * from './types';\n")
	b.WriteString("export * from './client';\n")
	b.WriteString("export * from './erst-integration';\n")

	return b.String()
}

// generatePackageJSON generates package.json for the bindings
func (g *Generator) generatePackageJSON() string {
	return fmt.Sprintf(`{
  "name": "%s",
  "version": "1.0.0",
  "description": "TypeScript bindings for Soroban smart contract",
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "@stellar/stellar-sdk": "^12.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  },
  "keywords": [
    "stellar",
    "soroban",
    "smart-contract",
    "blockchain"
  ],
  "license": "Apache-2.0"
}
`, g.config.PackageName)
}

// generateReadme generates README.md documentation
func (g *Generator) generateReadme() string {
	var b strings.Builder

	className := toPascalCase(g.config.PackageName) + "Client"

	b.WriteString(fmt.Sprintf("# %s\n\n", g.config.PackageName))
	b.WriteString("TypeScript bindings for Soroban smart contract, generated by `erst generate-bindings`.\n\n")

	b.WriteString("## Installation\n\n")
	b.WriteString("```bash\n")
	b.WriteString("npm install\n")
	b.WriteString("```\n\n")

	b.WriteString("## Usage\n\n")
	b.WriteString("```typescript\n")
	b.WriteString(fmt.Sprintf("import { %s } from './%s';\n\n", className, g.config.PackageName))

	b.WriteString("// Initialize client\n")
	b.WriteString(fmt.Sprintf("const client = new %s({\n", className))
	if g.config.ContractID != "" {
		b.WriteString(fmt.Sprintf("  contractId: '%s',\n", g.config.ContractID))
	} else {
		b.WriteString("  contractId: 'YOUR_CONTRACT_ID',\n")
	}
	b.WriteString(fmt.Sprintf("  network: '%s',\n", g.config.Network))
	b.WriteString("  enableSimulation: true, // Enable erst simulation\n")
	b.WriteString("});\n\n")

	b.WriteString("// Call contract methods\n")
	if len(g.spec.Functions) > 0 {
		fn := g.spec.Functions[0]
		b.WriteString(fmt.Sprintf("const result = await client.%s(\n", string(fn.Name)))
		b.WriteString("  sourceKeypair,\n")
		for _, inp := range fn.Inputs {
			b.WriteString(fmt.Sprintf("  %s, // %s\n", inp.Name, g.mapTypeDefToTS(inp.Type)))
		}
		b.WriteString("  { simulate: true } // Options\n")
		b.WriteString(");\n\n")
		b.WriteString("console.log('Result:', result);\n")
	}
	b.WriteString("```\n\n")

	b.WriteString("## Features\n\n")
	b.WriteString("- **Type-safe**: Fully typed contract methods and data structures\n")
	b.WriteString("- **Erst integration**: Built-in simulation and debugging with erst\n")
	b.WriteString("- **Network support**: Works with testnet, mainnet, and futurenet\n")
	b.WriteString("- **Error handling**: Strongly-typed error enums\n\n")

	b.WriteString("## Contract Methods\n\n")
	for _, fn := range g.spec.Functions {
		b.WriteString(fmt.Sprintf("### `%s`\n\n", string(fn.Name)))
		if fn.Doc != "" {
			b.WriteString(fmt.Sprintf("%s\n\n", fn.Doc))
		}

		if len(fn.Inputs) > 0 {
			b.WriteString("**Parameters:**\n\n")
			for _, inp := range fn.Inputs {
				b.WriteString(fmt.Sprintf("- `%s`: `%s`\n", inp.Name, g.mapTypeDefToTS(inp.Type)))
			}
			b.WriteString("\n")
		}

		if len(fn.Outputs) > 0 {
			b.WriteString(fmt.Sprintf("**Returns:** `%s`\n\n", g.mapTypeDefToTS(fn.Outputs[0])))
		}
	}

	b.WriteString("## Debugging with Erst\n\n")
	b.WriteString("```typescript\n")
	b.WriteString("// Simulate before executing\n")
	b.WriteString("const simResult = await client.someMethod(\n")
	b.WriteString("  sourceKeypair,\n")
	b.WriteString("  args,\n")
	b.WriteString("  { simulate: true }\n")
	b.WriteString(");\n\n")
	b.WriteString("// Check simulation results\n")
	b.WriteString("console.log('Budget usage:', simResult.simulation.budgetUsage);\n")
	b.WriteString("console.log('Events:', simResult.simulation.events);\n")
	b.WriteString("```\n\n")

	b.WriteString("## License\n\n")
	b.WriteString("Apache-2.0\n")

	return b.String()
}

// toPascalCase converts a string to PascalCase
func toPascalCase(s string) string {
	words := strings.FieldsFunc(s, func(r rune) bool {
		return r == '-' || r == '_' || r == ' '
	})

	for i, word := range words {
		if len(word) > 0 {
			words[i] = strings.ToUpper(word[:1]) + strings.ToLower(word[1:])
		}
	}

	return strings.Join(words, "")
}
